---
title: "ML1"
authors: "Alvaro Cervan, Luca Renz, Rafaella Miranda-Sousa
output: pdf_document
date: "2024-01-10"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Notizen Rafi
SVM Teil:
Cross validation or other methods for model comparing must be used on one single
methods (e.g. you use Cross Validation to compare 2-3 SVM models).
• Students are free to choose a measure of fit that they find more appropriate.
• In case students cannot find an appropriate measure of fit, they can use the Root Mean
Squared Error (RMSE).

Schließlich ist zu beachten, dass die Zusammenstellung von Dokumenten einige Zeit in Anspruch nehmen kann... insbesondere wenn komplexe
Modelle angepasst werden
- In diesen Fällen können Sie die Argumentationsoption cache = TRUE verwenden, so dass ein Chunk nur dann neu ausgewertet wird
nur dann neu ausgewertet wird, wenn er seit der letzten Kompilierung geändert wurde. Wenn der Chunk unverändert blieb
unverändert, dann werden die alten Ergebnisse verwendet




# Setup
```{r cars cache=TRUE}

#Install and import libraries.
if (!require("quantmod")) install.packages("quantmod")
if (!require("PortfolioAnalytics")) install.packages("PortfolioAnalytics")
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("ROI")) install.packages("ROI")
if (!require("ROI.plugin.quadprog")) install.packages("ROI.plugin.quadprog")
if (!require("fPortfolio")) install.packages("fPortfolio")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("lubridate")) install.packages("lubridate")
if (!require("corrplot")) install.packages("corrplot")
if (!require("dbscan")) install.packages("dbscan")
if (!require("dplyr")) install.packages("dplyr")
if (!require("GGally")) install.packages("GGally")
if (!require("tm")) install.packages("tm")
if (!require("tidytext")) install.packages("tidytext")
if (!require("wordcloud")) install.packages("wordcloud")


library(readr,quietly = T)
library(quantmod, quietly = T)
library(PortfolioAnalytics, quietly = T)
library(PerformanceAnalytics, quietly = T)
library(ggplot2, quietly = T)
library(ROI, quietly = T)
library(ROI.plugin.quadprog, quietly = T)
library(fPortfolio, quietly = T)
library(tidyverse, quietly = T)
library(lubridate, quietly = T)
library(corrplot, quietly = T)
library(dbscan)
library(dplyr)
library(GGally)
library(NLP)
library(RColorBrewer)
library(tm)
library(wordcloud)
library(tidytext)


# DATA LOAD
data_motor <- read_csv("data/motor_data14-2018.csv", show_col_types = FALSE)


#Alternativer Datensatz
#data_veh_ins<- read.csv("C:/Users/Ella-/MSc/2. Semester/ML1/machine-learning-1/data/Motor vehicle insurance data.csv", sep=";")
##Data Prep
## Umwandlung von Type_risk in eine ordinale kategoriale Variable
#data_veh_ins$Type_risk <- factor(data_veh_ins$Type_risk,
#                                 levels = c(1, 2, 3, 4),
#                                 labels = c("Motorbike", "Van", "Passenger Car", "Agricultural Vehicle"),
#                                 ordered = TRUE)
## Umwandlung von Payment in eine kategorische Variable mit den definierten Labels
#data_veh_ins$Payment <- factor(data_veh_ins$Payment,
#                               levels = c(0, 1),
#                               labels = c("Annual Payment", "Half-yearly Administrative Process"))
#
## Umwandlung von Area in eine kategorische Variable mit den definierten Labels
#data_veh_ins$Area <- factor(data_veh_ins$Area, levels = c(0, 1),
#                            labels = c("Rural", "Urban (more than 30K inhabitants)"))
#
## Umwandlung von Second_driver in eine kategorische Variable mit den definierten Labels
#data_veh_ins$Second_driver <- factor(data_veh_ins$Second_driver,
#                                     levels = c(0, 1), 
#                                     labels = c("One driver declared", "Multiple drivers declared"))
#
## Umwandlung von Distribution_channel in eine kategorische Variable mit den definierten Labels
#data_veh_ins$Distribution_channel <- factor(data_veh_ins$Distribution_channel,
#                                            levels = c(0, 1), 
#                                            labels = c("Agent", "Insurance Broker"))

#table(data_veh_ins$Type_risk)
#str(data_veh_ins)



```


Aus Quelle:
Some predictors such as carrying capacity and seat number are removed from the dataset prior
to data analysis and modeling since they are not correctly coded.


CHATGPT
CCM TON
Es macht keinen Sinn, dass Fahrzeuge einen Wert von 0 für die Variable CCM_TON haben, wenn diese Variable den Hubraum oder das Gewicht des Motors in Kubikzentimetern (ccm) oder Tonnen angibt.
Warum?
Der Hubraum (ccm) gibt das Volumen der Zylinder eines Verbrennungsmotors an. Ein Wert von 0 wäre unplausibel, da ein Fahrzeug ohne Hubraum keinen funktionsfähigen Motor hätte.
Wenn CCM_TON das Gewicht des Motors in Tonnen angibt, wäre ebenfalls ein Wert von 0 unplausibel, da ein Fahrzeug ohne Motorgewicht nicht funktionsfähig wäre.


```{r cars cache=TRUE}


#DATA PREP
data_motor$SEX <- factor(data_motor$SEX, 
                   levels = c(0, 1, 2), 
                   labels = c("Legal entity", "Male", "Female"))

data_motor$INSR_TYPE <- factor(data_motor$INSR_TYPE, 
                         levels = c(1201, 1202, 1204), 
                         labels = c("Private", "Commercial", "Motor trade road risk"))


#Cat var
data_motor$CLAIM_PAID_USD <- ifelse(is.na(data_motor$CLAIM_PAID), 0, data_motor$CLAIM_PAID)
data_motor$CLAIM_PAID <- ifelse(data_motor$CLAIM_PAID_USD == 0, "NO", "YES")


#Entfernen der Zeilen, bei denen TYPE_VEHICLE == "Trade plates" Da zu wenige Auspraegungen (5)
data_motor <- data_motor[data_motor$TYPE_VEHICLE != "Trade plates", ]


#NA
colSums(is.na(data_motor))

# Entfernen der Spalte CARRYING_CAPACITY
data_motor <- data_motor[ , !(names(data_motor) %in% "CARRYING_CAPACITY")]

#Zeilen mit PREMIUM NA und 0 entfernen
#Uberpruefung ob entfernen von PREMIUM = 0 vom Datensatz valide ist
data.frame(
  PREMIUM_0_Percent = 100 * mean(data_motor$PREMIUM == 0, na.rm = TRUE),
  PREMIUM_MORE_Percent = 100 * mean(data_motor$PREMIUM > 0, na.rm = TRUE))
data_motor <- data_motor[!(is.na(data_motor$PREMIUM) | data_motor$PREMIUM == 0), ]

#Zeilen mit PROD_YEAR NA entfernen
data_motor <- data_motor[!is.na(data_motor$PROD_YEAR),]

#Zeilen mit MAKE NA entfernen
data_motor <- data_motor[!is.na(data_motor$MAKE),]

#Zeilen mit SEATS_NUM NA entfernen
data_motor <- data_motor[!is.na(data_motor$SEATS_NUM),]





#SEATS_NUM
# Analyse SEATS_NUM: Anzahl der Zeilen mit SEATS_NUM == 0, NA und anderen Werten
data.frame(
  SEATS_NUM_0 = sum(data_motor$SEATS_NUM == 0, na.rm = TRUE),
  SEATS_NUM_NA = sum(is.na(data_motor$SEATS_NUM)),
  SEATS_NUM_OTHER = sum(data_motor$SEATS_NUM > 0, na.rm = TRUE)
)

# Relativ: Prozentsatz der Zeilen mit SEATS_NUM == 0, NA oder anderen Werten
data.frame(
  SEATS_NUM_0_or_NA_Percent = 100 * sum(is.na(data_motor$SEATS_NUM) | data_motor$SEATS_NUM == 0) / nrow(data_motor),
  SEATS_NUM_OTHER_Percent = 100 * sum(data_motor$SEATS_NUM > 0, na.rm = TRUE) / nrow(data_motor)
)

#Erstellen separater Datensätze für SEATS_NUM == 0 und SEATS_NUM > 0
data_seats_num_0 <- subset(data_motor, SEATS_NUM == 0)
data_seats_num_other <- subset(data_motor, SEATS_NUM > 0 & !is.na(SEATS_NUM))
# Tabellen der Fahrzeugtypen für beide Datensätze
table(data_seats_num_0$TYPE_VEHICLE)
table(data_seats_num_other$TYPE_VEHICLE)

#SEATS_NUM Alternative 1: Entfernen der Zeilen wo SEATS_NUM 0 oder NULL ist
#Liste der Fahrzeugtypen, bei denen SEATS_NUM == 0 unplausibel ist (Trailers and semitrailers, Tractor, Tanker werden gelassen)
unplausible_types <- c("Automobile", "Bus", "Motor-cycle", "Pick-up", "Station Wagones", "Tanker", "Truck")
# Entfernen der Zeilen, bei denen SEATS_NUM == 0 und der Fahrzeugtyp unplausibel ist
data_motor <- data_motor[!(data_motor$SEATS_NUM == 0 & data_motor$TYPE_VEHICLE %in% unplausible_types), ]


#SEATS_NUM Alternative 2: Entfernen der Zeilen wo SEATS_NUM 0 oder NULL ist
#data_motor <- data_motor[!(is.na(data_motor$SEATS_NUM) | data_motor$SEATS_NUM == 0), ]

#SEATS_NUM Alternative 3: Entfernen der SEATS_NUM-Spalte, da viele NA und schlechte Datenqualität
#data_motor <- subset(data_motor, select = -SEATS_NUM)



#CCM_TON
#Relativ CCM_TON 0
data.frame(
  CCM_TON_0_Percent = 100 * mean(data_motor$CCM_TON == 0, na.rm = TRUE),
  CCM_TON_MORE_Percent = 100 * mean(data_motor$CCM_TON > 0, na.rm = TRUE))
# Erstellen separater Datensätze für CCM_TON == 0 und CCM_TON > 0
data_CCM_TON_0 <- subset(data_motor, CCM_TON == 0)
data_CCM_TON_other <- subset(data_motor, CCM_TON > 0 & !is.na(CCM_TON))
# Tabellen der Fahrzeugtypen für beide Datensätze
table(data_CCM_TON_0$TYPE_VEHICLE)
table(data_CCM_TON_other$TYPE_VEHICLE)


# Liste der Fahrzeugtypen, bei denen CCM_TON == 0 unplausibel ist (Tractor,Trailers and semitrailers werden gelassen)
unplausible_types_ccm <- c("Automobile", "Bus", "Motor-cycle", "Pick-up", "Truck", "Station Wagones", "Tanker", "Special construction")
# Entfernen der Zeilen, bei denen CCM_TON == 0 und der Fahrzeugtyp unplausibel ist
data_motor <- data_motor[!(data_motor$CCM_TON == 0 & data_motor$TYPE_VEHICLE %in% unplausible_types_ccm), ]







data.frame(
  CLAIM_PAID_0 = sum(data_motor$CLAIM_PAID == 0, na.rm = TRUE),
  CLAIM_PAID_MORE_THAN_0 = sum(data_motor$CLAIM_PAID > 0, na.rm = TRUE))

data.frame(
  CLAIM_PAID_0_Percent = 100 * mean(data_motor$CLAIM_PAID == 0, na.rm = TRUE),
  CLAIM_PAID_MORE_THAN_0_Percent = 100 * mean(data_motor$CLAIM_PAID > 0, na.rm = TRUE))



#NA
colSums(is.na(data_motor)) 

```







```{r cars cache=TRUE}

#OLD


#DATA PREP
data_motor$CARRYING_CAPACITY<-as.numeric(data_motor$CARRYING_CAPACITY)

data_motor <- data_motor[, !names(data_motor) %in% "EFFECTIVE_YR"]
 
# Entfernen der Zeilen, wo 'make' nicht mit einem Buchstaben beginnt
data_motor <- data_motor[grepl("^[A-Za-z]", data_motor$MAKE), ] 
data_motor$CLAIM_PAID[is.na(data_motor$CLAIM_PAID)] <- 0
data_motor$CARRYING_CAPACITY[is.na(data_motor$CARRYING_CAPACITY)] <- 0
table(data_motor$TYPE_VEHICLE)
 
 
# LUCA
# Drop rows with NA values in specific columns
data_motor <- data_motor[!is.na(data_motor$PREMIUM) & !is.na(data_motor$PROD_YEAR) & !is.na(data_motor$CCM_TON) & !is.na(data_motor$MAKE) & !is.na(data_motor$SEATS_NUM), ]
# Check for the number of missing values in each column
colSums(is.na(data_motor))
# Create a new column to determine if the claim was paid
data_motor$CLAIM <- ifelse(data_motor$CLAIM_PAID == 0, 'NO', 'YES')

# Drop the INSR_TYPE column
data_motor <- data_motor[, !names(data_motor) %in% 'INSR_TYPE']
# Count how many zeros are in the INSURED_VALUE column
insured_value_zeros <- sum(data_motor$INSURED_VALUE == 0)
cat('Number of values with zero in insured value:', insured_value_zeros, '\n')
 
#FIXME to be discussed
# Calculate the median of INSURED_VALUE by TYPE_VEHICLE, MAKE, and PROD_YEAR 
median_insured_value <- ave(data_motor$INSURED_VALUE, data_motor$TYPE_VEHICLE, data_motor$MAKE, data_motor$PROD_YEAR, 
                            FUN = function(x) median(x, na.rm = TRUE))
 
# Replace 0s in INSURED_VALUE with the calculated median
data_motor$INSURED_VALUE[data_motor$INSURED_VALUE == 0] <- median_insured_value[data_motor$INSURED_VALUE == 0]

# Calculate the median of CARRYING_CAPACITY by TYPE_VEHICLE and MAKE
median_carrying_capacity <- ave(data_motor$CARRYING_CAPACITY, data_motor$TYPE_VEHICLE, data_motor$MAKE, 
                                FUN = function(x) median(x, na.rm = TRUE))
# Replace 0s in CARRYING_CAPACITY with the calculated median
data_motor$CARRYING_CAPACITY[data_motor$CARRYING_CAPACITY == 0] <- median_carrying_capacity[data_motor$CARRYING_CAPACITY == 0]


 
# Replace 0s in INSURED_VALUE with the calculated median
data_motor$INSURED_VALUE[data_motor$INSURED_VALUE == 0] <- median_insured_value[data_motor$INSURED_VALUE == 0]
 
 
# Calculate the median of CARRYING_CAPACITY by TYPE_VEHICLE and MAKE
#data_motor$CARRYING_CAPACITY[is.na(data_motor$CARRYING_CAPACITY)] <- 0

median_carrying_capacity <- ave(data_motor$CARRYING_CAPACITY, data_motor$TYPE_VEHICLE, data_motor$MAKE, 
                                FUN = function(x) median(x, na.rm = TRUE))
 
# Replace 0s in CARRYING_CAPACITY with the calculated median
data_motor$CARRYING_CAPACITY[data_motor$CARRYING_CAPACITY == 0] <- median_carrying_capacity[data_motor$CARRYING_CAPACITY == 0]
 
 
# Count how many zeros are in the PREMIUM column
premium_zeros <- sum(data_motor$PREMIUM == 0)
cat('Number of values with zero in premium:', premium_zeros, '\n')
data_motor <- data_motor[data_motor$PREMIUM != 0, ]
# Count how many zeros are in the CARRYING_CAPACITY column
carrying_capacity_zeros <- sum(data_motor$CARRYING_CAPACITY == 0)
cat('Number of values with zero in carrying capacity:', carrying_capacity_zeros, '\n')
# Count how many zeros are in the SEATS_NUM column
seats_num_zeros <- sum(data_motor$SEATS_NUM == 0)
cat('Number of values with zero in number of seats:', seats_num_zeros, '\n')


```



# Models
## Linear Model
```{r Linear-Model}
# TODO
str(data_motor)
summary(data_motor)

 #Premium= gender, insured value, prod_year, seats number, capacity, type vehicle,  cctm_ton, make, usage

# Erstelle das lineare Regressionsmodell mit den erklärenden Variablen
lm_model <- lm(PREMIUM ~ GENDER + INSURED_VALUE + PROD_YEAR + SEATS_NUM + CARRYING_CAPACITY + 
               TYPE_VEHICLE + CCM_TON + MAKE + USAGE, data = data_motor)

# Zusammenfassung des Modells anzeigen
summary(lm_model)


```


## Poisson
```{r Poisson-Model}
# TODO

```


## Binomial
```{r Binomial-Model}
# TODO

```

## Generalised Additive Model (GAM)
```{r GAM}
# TODO

```

## Neural Network
```{r Neural-Network}
# TODO

```


## Support Vector Machine (SVM)
```{r SVM}
# TODO

```


# Conclusion





