---
title: "ML1"
authors: "Alvaro Cervan, Luca Renz, Rafaella Miranda-Sousa
output: pdf_document
date: "2024-01-10"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Notizen Rafi
SVM Teil:
Cross validation or other methods for model comparing must be used on one single
methods (e.g. you use Cross Validation to compare 2-3 SVM models).
• Students are free to choose a measure of fit that they find more appropriate.
• In case students cannot find an appropriate measure of fit, they can use the Root Mean
Squared Error (RMSE).

Schließlich ist zu beachten, dass die Zusammenstellung von Dokumenten einige Zeit in Anspruch nehmen kann... insbesondere wenn komplexe
Modelle angepasst werden
- In diesen Fällen können Sie die Argumentationsoption cache = TRUE verwenden, so dass ein Chunk nur dann neu ausgewertet wird
nur dann neu ausgewertet wird, wenn er seit der letzten Kompilierung geändert wurde. Wenn der Chunk unverändert blieb
unverändert, dann werden die alten Ergebnisse verwendet




# Setup
```{r setup cache=TRUE}

#Install and import libraries.
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("ROI")) install.packages("ROI")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("lubridate")) install.packages("lubridate")
if (!require("corrplot")) install.packages("corrplot")
if (!require("dplyr")) install.packages("dplyr")
if (!require("GGally")) install.packages("GGally")
if (!require("mgcv")) install.packages("mgcv")  # Generalised Additive Model (GAM)
if (!require("nnet")) install.packages("nnet")  # Neural Networks
if (!require("e1071")) install.packages("e1071")  # Support Vector Machine (SVM)

library(readr,quietly = T)
library(ggplot2, quietly = T)
library(ROI, quietly = T)
library(tidyverse, quietly = T)
library(lubridate, quietly = T)
library(corrplot, quietly = T)
library(dplyr)
library(GGally)
library(mgcv)  # For Generalised Additive Models
library(nnet)  # For Neural Networks
library(e1071)  # For Support Vector Machine

```


Aus Quelle:
Some predictors such as carrying capacity and seat number are removed from the dataset prior
to data analysis and modeling since they are not correctly coded.


CHATGPT
CCM TON
Es macht keinen Sinn, dass Fahrzeuge einen Wert von 0 für die Variable CCM_TON haben, wenn diese Variable den Hubraum oder das Gewicht des Motors in Kubikzentimetern (ccm) oder Tonnen angibt.
Warum?
Der Hubraum (ccm) gibt das Volumen der Zylinder eines Verbrennungsmotors an. Ein Wert von 0 wäre unplausibel, da ein Fahrzeug ohne Hubraum keinen funktionsfähigen Motor hätte.
Wenn CCM_TON das Gewicht des Motors in Tonnen angibt, wäre ebenfalls ein Wert von 0 unplausibel, da ein Fahrzeug ohne Motorgewicht nicht funktionsfähig wäre.


```{r data prep cache=TRUE}

# DATA LOAD
data_motor <- read_csv("data/motor_data14-2018.csv", show_col_types = FALSE)

dim(data_motor)
str(data_motor)

#DATA PREP

#EFFECTIVE_YR
#Entfernen der Spalte EFFECTIVE_YR (Hat keinen Nutzen, da nicht entziffert werden kann)
data_motor <- data_motor[ , !(names(data_motor) %in% "EFFECTIVE_YR")]

#CARRYING_CAPACITY
#Entfernen der Spalte CARRYING_CAPACITY
data_motor <- data_motor[ , !(names(data_motor) %in% "CARRYING_CAPACITY")]

#CLAIM_PAID
data_motor$CLAIM_PAID_USD <- ifelse(is.na(data_motor$CLAIM_PAID), 0, data_motor$CLAIM_PAID)
data_motor$CLAIM_PAID <- ifelse(data_motor$CLAIM_PAID_USD == 0, "NO", "YES")

# Entfernen von Duplikaten und Zählen der entfernten Zeilen
removed_count <- nrow(data_motor) - nrow(data_motor <- distinct(data_motor))
# Ausgabe der Anzahl der entfernten Duplikate
cat("Anzahl der entfernten Duplikate:", removed_count, "\n")

#SEX
data_motor$SEX <- factor(data_motor$SEX, 
                   levels = c(0, 1, 2), 
                   labels = c("Legal entity", "Male", "Female"))
table(data_motor$SEX)

#INSR_BEGIN
data_motor$INSR_BEGIN <- dmy(data_motor$INSR_BEGIN)

#INSR_END
data_motor$INSR_END <- dmy(data_motor$INSR_END)

#INSR_TYPE
data_motor$INSR_TYPE <- factor(data_motor$INSR_TYPE, 
                         levels = c(1201, 1202, 1204), 
                         labels = c("Private", "Commercial", "Motor trade road risk"))

#INSURED_VALUE
#Überprüfen der Anzahl der fehlenden Werte
missing_values <- sum(is.na(data_motor$INSURED_VALUE))
cat("Fehlende Werte in INSURED_VALUE:", missing_values, "\n")

#Zusammenfassung der statistischen Kennzahlen
summary_stats <- summary(data_motor$INSURED_VALUE)
cat("Zusammenfassung der statistischen Kennzahlen von INSURED_VALUE:\n")
print(summary_stats)

#Ermittlung der Anzahl der Einträge, die 0 als Wert haben
zero_values <- sum(data_motor$INSURED_VALUE == 0, na.rm = TRUE)
cat("Anzahl der Einträge mit dem Wert 0 in INSURED_VALUE:", zero_values, "\n")

#Überprüfe, wie viele Datensätze betroffen sind
zero_insured_value <- data_motor[data_motor$INSURED_VALUE == 0, ]
cat("Anzahl der Datensätze mit INSURED_VALUE = 0:", nrow(zero_insured_value), "\n")

#Zusammenfassung der betroffenen Datensätze nach verschiedenen Variablen, um Muster zu erkennen
cat("Verteilung der Versicherungstypen (INSR_TYPE) bei INSURED_VALUE = 0:\n")
table(data_motor$INSR_TYPE) #Alle
print(table(zero_insured_value$INSR_TYPE)) #nur 0

cat("\nVerteilung der Fahrzeugtypen (TYPE_VEHICLE) bei INSURED_VALUE = 0:\n")
print(table(zero_insured_value$TYPE_VEHICLE))

cat("\nVerteilung der Fahrzeugnutzung (USAGE) bei INSURED_VALUE = 0:\n")
print(table(zero_insured_value$USAGE))

#Statistische Kennzahlen für andere Variablen bei INSURED_VALUE = 0 (z.B. PREMIUM)
cat("\nZusammenfassung der Prämien (PREMIUM) bei INSURED_VALUE = 0:\n")
summary(zero_insured_value$PREMIUM)

#Visualisierung der Fahrzeugnutzung bei INSURED_VALUE = 0
ggplot(zero_insured_value, aes(x = USAGE)) +
  geom_bar(fill = "blue", color = "black") +
  labs(title = "Verteilung der Fahrzeugnutzung bei INSURED_VALUE = 0", x = "Fahrzeugnutzung", y = "Anzahl") +
  theme_minimal()

#Fazit: Es wurde kein Zusammenhang festgestellt. Vermutlich ist der Versicherungswert von 0 darauf zurückzuführen, dass gesetzlich nur eine Haftpflichtversicherung erforderlich ist. In diesen Fällen gibt es keinen festgelegten Wert für Schäden am Fahrzeug selbst. Daher werden Datensätze mit einem INSURED_VALUE von 0 aus der Analyse entfernt, da sie keine relevanten Informationen für die Bewertung von Fahrzeugwerten enthalten.

#Entfernen der Zeilen, bei denen INSURED_VALUE gleich 0 ist
data_motor <- data_motor[data_motor$INSURED_VALUE != 0, ]

#Überprüfen, ob die Zeilen erfolgreich entfernt wurden
cat("Anzahl der verbleibenden Datensätze:", nrow(data_motor), "\n")

#Verteilung von INSURED_VALUE visualisieren (Histogramm)
ggplot(data_motor, aes(x = INSURED_VALUE)) +
  geom_histogram(binwidth = 50000, fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Verteilung von INSURED_VALUE", x = "Versicherter Wert", y = "Häufigkeit") +
  theme_minimal()

#Boxplot zur Identifizierung von Ausreissern
ggplot(data_motor, aes(y = INSURED_VALUE)) +
  geom_boxplot(fill = "orange", color = "black", alpha = 0.7) +
  labs(title = "Boxplot von INSURED_VALUE", y = "Versicherter Wert") +
  theme_minimal()

#Überprüfung der statistischen Kennzahlen ohne die 0-Werte
cat("Zusammenfassung der statistischen Kennzahlen ohne 0-Werte:\n")
print(summary(data_motor$INSURED_VALUE))

#Verteilung der log-transformierten INSURED_VALUE (nur für nicht-null Werte)
ggplot(data_motor[data_motor$INSURED_VALUE > 0, ], aes(x = log(INSURED_VALUE))) +
  geom_histogram(binwidth = 0.2, fill = "green", color = "black", alpha = 0.7) +
  labs(title = "Log-transformierte Verteilung von INSURED_VALUE (ohne Nullwerte)", x = "log(Versicherter Wert)", y = "Häufigkeit") +
  theme_minimal()

summary(data_motor$INSURED_VALUE)

#Ausreisser INSURED_VALUE entfernen 
data_motor <- data_motor[data_motor$INSURED_VALUE >= 10, ]
summary(data_motor$INSURED_VALUE)

#Workspace
rm(zero_insured_value)

#PREMIUM
#Uberpruefung ob entfernen von PREMIUM = 0 vom Datensatz valide ist
data.frame(
  PREMIUM_0_Percent = round(100 * sum(data_motor$PREMIUM == 0, na.rm = TRUE) / sum(!is.na(data_motor$PREMIUM)), 4),
  PREMIUM_NA_Percent = round(100 * sum(is.na(data_motor$PREMIUM)) / sum(!is.na(data_motor$PREMIUM)), 4),
  PREMIUM_MORE_Percent = round(100 * sum(data_motor$PREMIUM > 0, na.rm = TRUE) / sum(!is.na(data_motor$PREMIUM)), 4)
)

#Entfernen der Zeilen, bei denen PREMIUM NA oder 0 ist
data_motor <- data_motor[!(is.na(data_motor$PREMIUM) | data_motor$PREMIUM == 0), ]


# Entfernen von Duplikaten und Zählen der entfernten Zeilen
removed_count <- nrow(data_motor) - nrow(data_motor <- distinct(data_motor))
# Ausgabe der Anzahl der entfernten Duplikate
cat("Anzahl der entfernten Duplikate:", removed_count, "\n")

# OBJECT_ID
# Anzahl der Gesamtzeilen im Datensatz
total_rows <- nrow(data_motor)

# Anzahl der einzigartigen OBJECT_IDs
unique_object_ids <- length(unique(data_motor$OBJECT_ID))

# Überprüfen, ob OBJECT_IDs einmalig sind
if (total_rows == unique_object_ids) {
  cat("Die OBJECT_IDs sind einmalig.\n")
} else {
  cat("Die OBJECT_IDs sind NICHT einmalig.\n")
  cat("Anzahl der Duplikate:", total_rows - unique_object_ids, "\n")
  
  # Häufigkeit der OBJECT_IDs
  object_id_counts <- table(data_motor$OBJECT_ID)
  
  # Durchschnittliche und maximale Häufigkeit von OBJECT_ID
  avg_object_id_freq <- mean(object_id_counts)
  max_object_id_freq <- max(object_id_counts)
  
  cat("Durchschnittliche Häufigkeit der OBJECT_ID:", round(avg_object_id_freq, 3), "\n")
  cat("Maximale Häufigkeit der OBJECT_ID:", max_object_id_freq, "\n")
  
  # Häufigkeit der Kombination von OBJECT_ID, INSR_BEGIN, INSR_END, INSURED_VALUE und PREMIUM
  combo_counts <- data_motor %>%
    group_by(OBJECT_ID, INSR_BEGIN, INSR_END, INSURED_VALUE, PREMIUM) %>%
    summarise(count = n(), .groups = 'drop')
  
  # Durchschnittliche und maximale Häufigkeit der Kombination
  avg_combo_freq <- mean(combo_counts$count) # Durchschnittliche Häufigkeit der Kombination
  max_combo_freq <- max(combo_counts$count)   # Maximale Häufigkeit der Kombination
  
  cat("Durchschnittliche Häufigkeit der Kombination (OBJECT_ID, INSR_BEGIN, INSR_END, INSURED_VALUE, PREMIUM):", round(avg_combo_freq, 3), "\n")
  cat("Maximale Häufigkeit der Kombination (OBJECT_ID, INSR_BEGIN, INSR_END, INSURED_VALUE, PREMIUM):", max_combo_freq, "\n")
}

#Teilweise gibt es bei CLAIM_PAID== YES eine vervielfachung
#Korrektur bzw. entfernen dieser mehrfachen Zeilen
data_motor <- data_motor %>%
  group_by(SEX, INSR_BEGIN, INSR_END, INSR_TYPE, INSURED_VALUE, PREMIUM, OBJECT_ID, PROD_YEAR, SEATS_NUM, TYPE_VEHICLE, CCM_TON, MAKE, USAGE) %>%
  # Zähle die Anzahl der Zeilen in jeder Gruppe
  mutate(group_size = n()) %>%
  ungroup() %>%
  # Entferne Zeilen nur, wenn es eine Doppelzeile gibt und CLAIM_PAID == "NO" und CLAIM_PAID_USD <= 1
  filter(!(group_size > 1 & CLAIM_PAID == "NO" & CLAIM_PAID_USD <= 1)) %>%
  select(-group_size)  # Entferne die Hilfsspalte

#Korrektur Wiederspruch bei INSR_TYPE
data_motor <- data_motor %>%
  group_by(SEX, INSR_BEGIN, INSR_END, INSURED_VALUE, PREMIUM, OBJECT_ID, PROD_YEAR, SEATS_NUM, TYPE_VEHICLE, CCM_TON, MAKE, USAGE) %>%
  filter(!(n() > 1 & INSR_TYPE != "Commercial")) %>%  # Behalte nur die Zeilen mit "Commercial"
  ungroup()  # Ungroup, um das Gruppierungsobjekt zu entfernen

#Clear Workspace
rm(combo_counts)


#Entfernen der Zeilen, bei denen TYPE_VEHICLE == "Trade plates" Da zu wenige Auspraegungen (11)
table(data_motor$TYPE_VEHICLE)
data_motor <- data_motor[data_motor$TYPE_VEHICLE != "Trade plates", ]


#NA
colSums(is.na(data_motor))







#Zeilen mit PROD_YEAR NA entfernen
data_motor <- data_motor[!is.na(data_motor$PROD_YEAR),]

#Zeilen mit MAKE NA entfernen
data_motor <- data_motor[!is.na(data_motor$MAKE),]


# Korrektur der Tippfehler für Toyota, Renault, HIGHBENCARGO und Mercedes in der Spalte MAKE
# Liste der zu korrigierenden Mercedes-Varianten
mercedes_variants <- c("MERCHEDES", "MERCEEDES", "MERCEEDICE", 
                        "MERCEDIS", "MERCEDES / 2521-48", 
                        "MERCEDES ATEGO-KELES", "MERCEDES BENZ", 
                        "MERCEDES/SANY", "MERCEDES AXOR")

# Setze die Einträge in der Spalte MAKE auf "MERCEDES"
data_motor$MAKE[data_motor$MAKE %in% mercedes_variants] <- "MERCEDES"

# Korrektur der Einträge für Volkswagen in der Spalte MAKE
data_motor$MAKE[data_motor$MAKE %in% c("VOLKS WAGON", "VOLKSWAGON", "VOLS WAGEN", 
                                        "VOLS WAGON", "VOLSVAGON", "VOWS WAGEN")] <- "VOLKSWAGEN"

data_motor$MAKE[data_motor$MAKE %in% c("RENALT", "RENUALT", "RENAULT/STOLARCZYK", "RENAULT*")] <- "RENAULT"

# Liste der zu korrigierenden Mitsubishi-Varianten
mitsubishi_variants <- c("MISTIBUSH", "MITSUBISHI*", "MITSUBUSHI")

# Setze die Einträge in der Spalte MAKE auf "MITSUBISHI"
data_motor$MAKE[data_motor$MAKE %in% mitsubishi_variants] <- "MITSUBISHI"


# Liste der zu korrigierenden Toyota-Varianten
toyota_variants <- c("TOYATA", "TOYOTA", "TOYOTA  AUTOMOBILE", "T0Y0TA", "TOYOTA  COROLA", 
                      "TOYOTA  YARIS", "TOYOTA 4 RUNNER", "TOYOTA AUTOMOBILE", 
                      "TOYOTA COROLLA", "TOYOTA HIACE", "TOYOTA HILUX", 
                      "TOYOTA JAPAN", "TOYOTA L/C PRADO", "TOYOTA L/CRUISER", 
                      "TOYOTA LAND CRUISER", "TOYOTA MINIBUS", 
                      "TOYOTA P/UP", "TOYOTA PICK-UP", "TOYOTA PLATZ", 
                      "TOYOTA RAV4", "TOYOTA RAVA4", "TOYOTA REVO HILUX", 
                      "TOYOTA VANZE", "TOYOTA VITIZ", "TOYOTA VITZ", 
                      "TOYOTA YARIS", "TOYOTA*", "TOYOTAA", "TOYTA", 
                      "TRACKS MOBILE DIMAGE CRANE")

# Setze die Einträge in der Spalte MAKE auf "TOYOTA"
data_motor$MAKE[data_motor$MAKE %in% toyota_variants] <- "TOYOTA"


data_motor$MAKE[data_motor$MAKE %in% c("RENGE  ROVER")] <- "RANGE ROVER"


data_motor$MAKE <- gsub("RENUALT", "RENAULT", data_motor$MAKE)
data_motor$MAKE <- gsub("RENAULT\\*", "RENAULT", data_motor$MAKE)  # Entferne Stern
data_motor$MAKE <- gsub("TOYATA", "TOYOTA", data_motor$MAKE)
data_motor$MAKE <- gsub("TOYOTA\\*", "TOYOTA", data_motor$MAKE)    # Entferne Stern
data_motor$MAKE <- gsub("HIGHBENCARGOTRAUCK", "HIGHBENCARGO", data_motor$MAKE)


# Liste der ungültigen oder nicht existierenden Marken, die entfernt werden sollen
invalid_makes <- c("*", "1982", "1984", "1985", "2011", 
                   "2 AXEL LOWBED", "3-AXLE DRAWBAR CARGO TRAILER", "330-30 TRAILER", 
                   "4WDTUAB TERES COPIC HANDLER", "B.AKEL", 
                   "AUTOMOBIL", "AUTOMOBILE", "BAJAJI", 
                   "MERCEDES / 2521-48", "P/UP")

# Entfernen der ungültigen Marken aus dem Datensatz
data_motor <- data_motor[!(data_motor$MAKE %in% invalid_makes), ]



#Zeilen mit SEATS_NUM NA entfernen
data_motor <- data_motor[!is.na(data_motor$SEATS_NUM),]





#SEATS_NUM
# Analyse SEATS_NUM: Anzahl der Zeilen mit SEATS_NUM == 0, NA und anderen Werten
data.frame(
  SEATS_NUM_0 = sum(data_motor$SEATS_NUM == 0, na.rm = TRUE),
  SEATS_NUM_NA = sum(is.na(data_motor$SEATS_NUM)),
  SEATS_NUM_OTHER = sum(data_motor$SEATS_NUM > 0, na.rm = TRUE)
)

# Relativ: Prozentsatz der Zeilen mit SEATS_NUM == 0, NA oder anderen Werten
data.frame(
  SEATS_NUM_0_or_NA_Percent = 100 * sum(is.na(data_motor$SEATS_NUM) | data_motor$SEATS_NUM == 0) / nrow(data_motor),
  SEATS_NUM_OTHER_Percent = 100 * sum(data_motor$SEATS_NUM > 0, na.rm = TRUE) / nrow(data_motor)
)

#Erstellen separater Datensätze für SEATS_NUM == 0 und SEATS_NUM > 0
data_seats_num_0 <- subset(data_motor, SEATS_NUM == 0)
data_seats_num_other <- subset(data_motor, SEATS_NUM > 0 & !is.na(SEATS_NUM))
# Tabellen der Fahrzeugtypen für beide Datensätze
table(data_seats_num_0$TYPE_VEHICLE)
table(data_seats_num_other$TYPE_VEHICLE)

#SEATS_NUM Alternative 1: Entfernen der Zeilen wo SEATS_NUM 0 oder NULL ist
#Liste der Fahrzeugtypen, bei denen SEATS_NUM == 0 unplausibel ist (Trailers and semitrailers, Tractor, Tanker werden gelassen)
unplausible_types <- c("Automobile", "Bus", "Motor-cycle", "Pick-up", "Station Wagones", "Tanker", "Truck")
# Entfernen der Zeilen, bei denen SEATS_NUM == 0 und der Fahrzeugtyp unplausibel ist
data_motor <- data_motor[!(data_motor$SEATS_NUM == 0 & data_motor$TYPE_VEHICLE %in% unplausible_types), ]


#SEATS_NUM Alternative 2: Entfernen der Zeilen wo SEATS_NUM 0 oder NULL ist
#data_motor <- data_motor[!(is.na(data_motor$SEATS_NUM) | data_motor$SEATS_NUM == 0), ]

#SEATS_NUM Alternative 3: Entfernen der SEATS_NUM-Spalte, da viele NA und schlechte Datenqualität
#data_motor <- subset(data_motor, select = -SEATS_NUM)



#CCM_TON
#Relativ CCM_TON 0
data.frame(
  CCM_TON_0_Percent = 100 * mean(data_motor$CCM_TON == 0, na.rm = TRUE),
  CCM_TON_MORE_Percent = 100 * mean(data_motor$CCM_TON > 0, na.rm = TRUE))
# Erstellen separater Datensätze für CCM_TON == 0 und CCM_TON > 0
data_CCM_TON_0 <- subset(data_motor, CCM_TON == 0)
data_CCM_TON_other <- subset(data_motor, CCM_TON > 0 & !is.na(CCM_TON))
# Tabellen der Fahrzeugtypen für beide Datensätze
table(data_CCM_TON_0$TYPE_VEHICLE)
table(data_CCM_TON_other$TYPE_VEHICLE)


# Liste der Fahrzeugtypen, bei denen CCM_TON == 0 unplausibel ist (Tractor,Trailers and semitrailers werden gelassen)
unplausible_types_ccm <- c("Automobile", "Bus", "Motor-cycle", "Pick-up", "Truck", "Station Wagones", "Tanker", "Special construction")
# Entfernen der Zeilen, bei denen CCM_TON == 0 und der Fahrzeugtyp unplausibel ist
data_motor <- data_motor[!(data_motor$CCM_TON == 0 & data_motor$TYPE_VEHICLE %in% unplausible_types_ccm), ]







data.frame(
  CLAIM_PAID_0 = sum(data_motor$CLAIM_PAID == 0, na.rm = TRUE),
  CLAIM_PAID_MORE_THAN_0 = sum(data_motor$CLAIM_PAID > 0, na.rm = TRUE))

data.frame(
  CLAIM_PAID_0_Percent = 100 * mean(data_motor$CLAIM_PAID == 0, na.rm = TRUE),
  CLAIM_PAID_MORE_THAN_0_Percent = 100 * mean(data_motor$CLAIM_PAID > 0, na.rm = TRUE))



#NA
colSums(is.na(data_motor)) 

rm(data_CCM_TON_0)
rm(data_CCM_TON_other)
rm(data_seats_num_0)
rm(data_seats_num_other)

```







```{r cars cache=TRUE}

#OLD


#DATA PREP
data_motor$CARRYING_CAPACITY<-as.numeric(data_motor$CARRYING_CAPACITY)

data_motor <- data_motor[, !names(data_motor) %in% "EFFECTIVE_YR"]
 
# Entfernen der Zeilen, wo 'make' nicht mit einem Buchstaben beginnt
data_motor <- data_motor[grepl("^[A-Za-z]", data_motor$MAKE), ] 
data_motor$CLAIM_PAID[is.na(data_motor$CLAIM_PAID)] <- 0
data_motor$CARRYING_CAPACITY[is.na(data_motor$CARRYING_CAPACITY)] <- 0
table(data_motor$TYPE_VEHICLE)
 
 
# LUCA
# Drop rows with NA values in specific columns
data_motor <- data_motor[!is.na(data_motor$PREMIUM) & !is.na(data_motor$PROD_YEAR) & !is.na(data_motor$CCM_TON) & !is.na(data_motor$MAKE) & !is.na(data_motor$SEATS_NUM), ]
# Check for the number of missing values in each column
colSums(is.na(data_motor))
# Create a new column to determine if the claim was paid
data_motor$CLAIM <- ifelse(data_motor$CLAIM_PAID == 0, 'NO', 'YES')

# Drop the INSR_TYPE column
data_motor <- data_motor[, !names(data_motor) %in% 'INSR_TYPE']
# Count how many zeros are in the INSURED_VALUE column
insured_value_zeros <- sum(data_motor$INSURED_VALUE == 0)
cat('Number of values with zero in insured value:', insured_value_zeros, '\n')
 
#FIXME to be discussed
# Calculate the median of INSURED_VALUE by TYPE_VEHICLE, MAKE, and PROD_YEAR 
median_insured_value <- ave(data_motor$INSURED_VALUE, data_motor$TYPE_VEHICLE, data_motor$MAKE, data_motor$PROD_YEAR, 
                            FUN = function(x) median(x, na.rm = TRUE))
 
# Replace 0s in INSURED_VALUE with the calculated median
data_motor$INSURED_VALUE[data_motor$INSURED_VALUE == 0] <- median_insured_value[data_motor$INSURED_VALUE == 0]

# Calculate the median of CARRYING_CAPACITY by TYPE_VEHICLE and MAKE
median_carrying_capacity <- ave(data_motor$CARRYING_CAPACITY, data_motor$TYPE_VEHICLE, data_motor$MAKE, 
                                FUN = function(x) median(x, na.rm = TRUE))
# Replace 0s in CARRYING_CAPACITY with the calculated median
data_motor$CARRYING_CAPACITY[data_motor$CARRYING_CAPACITY == 0] <- median_carrying_capacity[data_motor$CARRYING_CAPACITY == 0]


 
# Replace 0s in INSURED_VALUE with the calculated median
data_motor$INSURED_VALUE[data_motor$INSURED_VALUE == 0] <- median_insured_value[data_motor$INSURED_VALUE == 0]
 
 
# Calculate the median of CARRYING_CAPACITY by TYPE_VEHICLE and MAKE
#data_motor$CARRYING_CAPACITY[is.na(data_motor$CARRYING_CAPACITY)] <- 0

median_carrying_capacity <- ave(data_motor$CARRYING_CAPACITY, data_motor$TYPE_VEHICLE, data_motor$MAKE, 
                                FUN = function(x) median(x, na.rm = TRUE))
 
# Replace 0s in CARRYING_CAPACITY with the calculated median
data_motor$CARRYING_CAPACITY[data_motor$CARRYING_CAPACITY == 0] <- median_carrying_capacity[data_motor$CARRYING_CAPACITY == 0]
 
 
# Count how many zeros are in the PREMIUM column
premium_zeros <- sum(data_motor$PREMIUM == 0)
cat('Number of values with zero in premium:', premium_zeros, '\n')
data_motor <- data_motor[data_motor$PREMIUM != 0, ]
# Count how many zeros are in the CARRYING_CAPACITY column
carrying_capacity_zeros <- sum(data_motor$CARRYING_CAPACITY == 0)
cat('Number of values with zero in carrying capacity:', carrying_capacity_zeros, '\n')
# Count how many zeros are in the SEATS_NUM column
seats_num_zeros <- sum(data_motor$SEATS_NUM == 0)
cat('Number of values with zero in number of seats:', seats_num_zeros, '\n')


```



# Models
## Linear Model
```{r Linear-Model}
# TODO
str(data_motor)
summary(data_motor)

 #Premium= gender, insured value, prod_year, seats number, capacity, type vehicle,  cctm_ton, make, usage

# Erstelle das lineare Regressionsmodell mit den erklärenden Variablen
lm_model <- lm(PREMIUM ~ GENDER + INSURED_VALUE + PROD_YEAR + SEATS_NUM + CARRYING_CAPACITY + 
               TYPE_VEHICLE + CCM_TON + MAKE + USAGE, data = data_motor)

# Zusammenfassung des Modells anzeigen
summary(lm_model)


```


## Poisson
```{r Poisson-Model}
# TODO

```


## Binomial
```{r Binomial-Model}
# TODO

```

## Generalised Additive Model (GAM)
```{r GAM}
# TODO

```

## Neural Network
```{r Neural-Network}
# TODO

```


## Support Vector Machine (SVM)
```{r SVM}
# TODO

```


# Conclusion





